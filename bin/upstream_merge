#!/usr/bin/env ruby

require 'optparse'
require_relative '../init'

Options = Struct.new(
  :dry_run,
  :force,
  :mention_people
)

class OptionParser
  class << self
    def parse(argv)
      options = Options.new

      # Defaults
      options.dry_run = false
      options.force = false
      options.mention_people = true

      parser = OptionParser.new do |opts|
        # Take a look at banner, Michael!
        opts.banner = <<~BANNER
          Usage: #{__FILE__} [options]

          1. Merges the latest CE master} into the latest EE master
          2. Pushes the merge to a new (unique per day) branch
          3. Creates a Merge Request that will include:
            * A list of the files for which conflicts need to be resolved.
            * Mentions of the last person who updated a conflicting file

        BANNER

        opts.on('-n', '--dry-run', "Don't push a new branch or create the merge request") do |value|
          options.dry_run = value
        end

        opts.on('-f', '--force', "Create a branch and merge request even if another upstream merge is alreaady in progress") do |value|
          options.force = value
        end

        opts.on('--no-mention', "Don't notify people in the MR description") do |value|
          options.mention_people = value
        end

        opts.on('-h', '--help', 'Print help message') do
          $stdout.puts opts
          exit
        end
      end

      parser.parse!(argv)

      options
    end
  end
end

if $0 == __FILE__
  options = OptionParser.parse(ARGV)

  result = Services::UpstreamMergeService
    .new(options)
    .perform

  if result.success?
    upstream_mr = result.payload[:upstream_mr]
    if upstream_mr.exists?
      $stdout.puts <<~SUCCESS_MESSAGE.colorize(:green)
        --> Merge request "#{upstream_mr.title}" created.
            #{upstream_mr.url}
      SUCCESS_MESSAGE
      Slack::UpstreamMergeNotification.new_merge_request(upstream_mr) unless options.dry_run
    else
      $stdout.puts <<~SUCCESS_MESSAGE.colorize(:yellow)
        --> Merge request "#{upstream_mr.title}" not created.
      SUCCESS_MESSAGE
      Slack::UpstreamMergeNotification.missing_merge_request unless options.dry_run
    end
  elsif result.payload[:in_progress_mr]
    in_progress_mr = result.payload[:in_progress_mr]
    $stdout.puts <<~ERROR_MESSAGE.colorize(:red)
    --> An upstream merge request already exists.
        #{in_progress_mr.url}
    ERROR_MESSAGE
    Slack::UpstreamMergeNotification.existing_merge_request(in_progress_mr) unless options.dry_run
  elsif result.payload[:already_up_to_date]
    $stdout.puts <<~ERROR_MESSAGE.colorize(:green)
    --> EE is already up-to-date with CE. No merge request was created.
    ERROR_MESSAGE
    Slack::UpstreamMergeNotification.downstream_is_up_to_date unless options.dry_run
  end
end

# vim: ft=ruby
